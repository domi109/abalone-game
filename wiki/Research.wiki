#summary Lists all research found by team

= Table of Contents =
<wiki:toc max_depth="3"/>

=Introduction =
[http://en.wikipedia.org/wiki/Abalone_(board_game) Abalone] is a two-person [http://en.wikipedia.org/wiki/Zero-sum zero-sum] board game, with [http://en.wikipedia.org/wiki/Perfect_information perfect information]. This is a quick overview of different approaches to [http://en.wikipedia.org/wiki/Artificial_intelligence artificial intelligence] which could be interesting to implement into the [http://code.google.com/p/abalone-game/ abalone-game].

== Game Complexity ==
Game complexity deals with how complex

=== Space-State Complexity ===


=== Game-Tree Complexity ===

=== Complexity of Abalone ===
The average game-length of Abalone, between human players, is around 87 [http://en.wikipedia.org/wiki/Ply_(game_theory) ply]. By contrast the average game-length of Abalone, between computer players, is around 130 ply, as computer players play more conservative/defensive. The average [http://en.wikipedia.org/wiki/Branching_factor branching factor] is around 60 - 65.

The space-state complexity of Abalone is similar to Checkers, and since checkers has been solved, it could be solved for Abalone. So space-state complexity for Abalone is low. Having said that, the game-tree complexity of Abalone is complex, due to the high branching factor (As a comparison the branching factor for Chess is around 35, half that of Abalone). Therefore the game-tree complexity of Abalone is high. Overall this leads to a relatively complex game, which is not easy to solve. 

== Game Tree Search Algorithms ==

=== Minimax Algorithm ===
[https://chessprogramming.wikispaces.com/Minimax resource].
[http://en.wikipedia.org/wiki/Minimax Minimax] is algorithm.

_Pseudo Code_:
{{{
public int Max(int depth) {
    if (depth == 0) return evaluate();
    int max = -infinity;
    for (all moves) {
    	score = Min(depth - 1);
        if(score > max)
            max = score;
    }
    return max;
}
 
public int Min(int depth) {
    if (depth == 0) return -evaluate();
    int min = +infinity;
    for (all moves) {
        score = Max(depth - 1);
        if(score < min)
            min = score;
    }
    return min;
}
}}}

_Advantages_:
 # Easy to implement.
 # Benchmark algorithm (ie. defacto algorithm).
_Disadvantages_:
 # Does not prune branches.
 # Needs two separate methods (Max and Min).

=== Negamax Algorithm === 
[https://chessprogramming.wikispaces.com/Negamax resource].
[http://en.wikipedia.org/wiki/Negamax Negamax] is a simplified variant of Minimax.

_Pseudo Code_:
{{{
public int Negamax(int depth) {
    	if (depth == 0) return evaluate();
    	int max = -infinity;
    	for (all moves)  {
        	score = -Negamax(depth - 1);
        	if(score > max)
            		max = score;
    	}
    	return max;
}
}}}

_Advantages_:
 # Easy to implement.
 # Only one method, instead of two like Minimax.
_Disadvantages_:
 # Does not prune branches.

=== Alpha-Beta Pruning ===
[https://chessprogramming.wikispaces.com/Alpha-Beta resource].
[http://en.wikipedia.org/wiki/Alpha-beta_pruning Alpha-Beta] is

=== Negascout Algorithm ===
[https://chessprogramming.wikispaces.com/NegaScout resource].
[http://en.wikipedia.org/wiki/Negascout Negascout] is

=== SSS Star Algorithm ===
[https://chessprogramming.wikispaces.com/SSS*+and+Dual* resource].
[http://en.wikipedia.org/wiki/SSS* SSS Star] is

=== MTD(f) Algorithm ===
[https://chessprogramming.wikispaces.com/MTD%28f%29 resource].
[http://en.wikipedia.org/wiki/MTD(f) MTD(f)] is

=== Iterative Deepening ===
[https://chessprogramming.wikispaces.com/Iterative+Deepening resource].
[http://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search Iterative Deepening] is

=== Transposition Table ===
A [http://en.wikipedia.org/wiki/Transposition_table transposition table] is a table which monitors all possible moves analyzed, and makes sure no double moves are analyzed. It is often done through the use of a [http://en.wikipedia.org/wiki/Hash_table hash table].

[https://chessprogramming.wikispaces.com/Zobrist+Hashing Zorbrit's hashing].
[https://chessprogramming.wikispaces.com/Transposition+Table resource].  

== Evaluation Functions ==
A [http://en.wikipedia.org/wiki/Evaluation_function evaluation function] is a function which estimates how good 

=== ABLA Evaluation Function ===
Is a weighted linear evaluation function is from the paper

eval(_s_) = w,,1,,f,,1,,(_s_) + w,,2,,f,,2,,(_s_)

_Where_:
 * f,,1,,(_s_): The difference between the sum of the Manhattan distances of marbles for each players, for a given board state _s_.
 * w,,1,,: Is the weight for f,,1,,(_s_).
 * f,,2,,(_s_): The difference between the sum of the number of neighboring teammates for marbles for each players, for a given board state _s_.
 * w,,2,,: Is the weight for f,,2,,(_s_).

=== Lemmens Evaluation Function ===
This evaluation function is from the paper

eval(_s_) = w,,1,,f,,1,,(_s_) + w,,2,,f,,2,,(_s_) + w,,3,,f,,3,,(_s_) + w,,4,,f,,4,,(_s_) + w,,5,,f,,5,,(_s_) - w,,6,,f,,6,,(_s_)

_Where_:
 * f,,1,,(_s_): The difference between the sum of the Manhattan distances of marbles for each players, for a given board state s. 
 * w,,1,,: Is the weight for f,,1,,(_s_).
 * f,,2,,(_s_):The difference between the sum of the number of neighboring teammates for marbles for each players, for a given board state _s_.
 * w,,2,,: Is the weight for f,,2,,(_s_).
 * f,,3,,(_s_): 
 * w,,3,,: Is the weight for f,,3,,(_s_).
 * f,,4,,(_s_):
 * w,,4,,: Is the weight for f,,4,,(_s_).
 * f,,5,,(_s_): 
 * w,,5,,: Is the weight for f,,5,,(_s_).
 * f,,6,,(_s_):
 * w,,6,,: Is the weight for f,,6,,(_s_).

== Machine Learning ==
Machine learning could be applied to the evaluation functions, by for example, optimizing the weights in the evaluation functions.

One possibility is to use a genetic algorithm to learn the optimal weights.

== Monte Carlo Methods ==
Normal Monte Carlo Search seems poor. But might have a look into Monte Carlo Tree Search methods, as they seem to be promising.

= References =
[http://dme.uma.pt/people/faculty/pedro.campos/papers/Abalearn.pdf Abalearn: Efficient Self-Play Learning of the game Abalone] by Pedro Campos and Thibault Langlois.

[http://books.google.nl/books?id=L4h2A2vF2pUC&pg=PA35&lpg=PA35&dq=%22machine+learning%22%2Babalone&source=bl&ots=3KOwjAK1zv&sig=kTf2yF8uy4t8g8Jx8r09T9jvd_M&hl=nl&ei=sfqxSvOwN8bi-QaZvsXcCQ&sa=X&oi=book_result&ct=result&resnum=5#v=onepage&q=%22machine%20learning%22%2Babalone&f=false Abalearn: A Risk-Sensitive Approach to Self-play Learning in Abalone] by Pedro Campos and Thibault Langlois.

[http://cse.yeditepe.edu.tr/~eozcan/research/papers/ABLA_id136final.pdf A Simple Intelligent Agent for Playing Abalone Game: ABLA] by Ender Ozcan and Berk Hulagu.

[http://www.cs.unimaas.nl/~uiterwyk/Theses/BSc/Lemmens_BSc-paper.pdf Constructing an Abalone Game-Playing Agent] by N.P.P.M. Lemmens.

[http://www.unimaas.nl/games/files/msc/pcreport.pdf Implementing a Computer Player for Abalone using Alpha-Beta and Monte-Carlo Search] by Pascal Chorus.

[http://www.ist.tugraz.at/staff/aichholzer/research/rp/abalone/tele1-02_aich-abalone.pdf Algorithmic Fun - Abalone] by Oswin Aichholzer, Franz Aurenhammer, and Tino Werner.

[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.114.6831&rep=rep1&type=pdf Abalone â€“ Final Project Report] by Benson Lee, Hyun Joo Noh.

[http://sander.landofsand.com/publications/Monte-Carlo_Tree_Search_-_A_New_Framework_for_Game_AI.pdf Monte-Carlo Tree Search: A New Framework for Game AI] by Guillaume Chaslot, Sander Bakkes, Istvan Szita, and Pieter Spronck.

[http://www.ru.is/faculty/yngvi/pdf/WinandsBS08.pdf Monte-Carlo Tree Search Solver] by Mark H.M. Winands , Yngvi Bjornsson, and Jahn-Takeshi Saito.

[http://www.springerlink.com/content/q0v51v7j311um169/ Heuristic evaluation functions in artificial intelligence search algorithms] by Richard E. Korf (Need SpringerLink access, can be accessed for free at uni). 

[http://stackoverflow.com/questions/1291377/how-do-i-create-a-good-evaluation-function-for-a-new-board-game Forum discussion] about evaluation functions.

[http://www.hamedahmadi.com/gametree/ An Introduction to Game Tree Algorithms] by Hamed Ahmadi.


[http://www.iis.sinica.edu.tw/~tshsu/tcg2009/index.html Theory of Computer Games: Fall 2009] by Tsan-sheng Hsu.  

link to [http://www.ist.tugraz.at/staff/aichholzer/research/rp/abalone/ ABA-PRO] game. 

===Opponent Modeling===
[http://www.cs.kuleuven.be/~dtai/publications/files/38667.ps.gz Opponent modeling by analyzing play]
[http://www.fdg.unimaas.nl/educ/donkers/pdf/kag2004.pdf Opponent Models and Knowledge Symmetry in Game-Tree Search] by Jeroen Donkers