package nl.maastrichtuniversity.dke.libreason.impl.treesearch;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

import nl.maastrichtuniversity.dke.libreason.def.Action;
import nl.maastrichtuniversity.dke.libreason.def.SearchState;
import nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode;


/**
 * A class that extends this abstract class can serve as a SearchNode in a
 * {@link IDTreeSearch}. The method expand that generates the successor nodes has
 * to be implemented by the child class.
 * 
 * Some ideas for this class are taken from
 * "Artificial Intelligence - A Modern Approach" (Russel, Norvig)
 * 
 * @author Daniel Mescheder
 */
public abstract class AbstractSearchNode implements Serializable, SearchNode
{
	private static final long serialVersionUID = -3043848397791138974L;
	// The state that this node refers to
	private SearchState searchState;
	// The parent node which leads to this node
	private SearchNode parent;
	// The price to get to this node from the start node
	private double pathCost;
	// The action that leads to this node
	private Action action;
	private int depth;

	/**
	 * Creates a new SearchNode object which refers to a given SearchState s and
	 * has the second parameter as its parent.
	 * 
	 * @param s
	 *            The SearchState object which the new node refers to
	 * @param parent
	 *            The SearchNode object which is a parent for the new SearchNode
	 * @param a The action that leads to this state
	 */
	public AbstractSearchNode(SearchState s, SearchNode parent, Action a)
	{
		this.searchState = s;
		this.parent = parent;
		this.action = a;
		this.pathCost = parent.getPathCost() + a.getCost();
		this.depth = parent.getDepth() + 1;
	}

	/**
	 * Creates a new SearchNode object which refers to a given SearchState s.
	 * 
	 * @param s
	 *            The SearchState object which the new node refers to
	 */
	public AbstractSearchNode(SearchState s)
	{
		this.searchState = s;
		this.parent = null;
		this.pathCost = 0;
		this.action = null;
		this.depth = 0;
	}

	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#getState()
	 */
	public SearchState getState()
	{
		return searchState;
	}

	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#expand()
	 */
	public abstract Queue<SearchNode> expand();

	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#getPathCost()
	 */
	public double getPathCost()
	{
		return pathCost;
	}

	/**
	 * Generates a formatted string for this node.
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
		String ret = "SearchNode{\nAction leading to node: ";
		ret += (action == null) ? "<?>\n" :action.toString() + "\n";
		ret += searchState.toString();
		ret += "\n}";

		return ret;

	}

	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#getPath()
	 */
	public List<Action> getPath()
	{
		ArrayList<Action> a = new ArrayList<Action>();
		if (parent != null)
		{
			a.addAll(parent.getPath());
		}
		if (action != null)
		{
			a.add(action);
		}
		return a;
		
	}

	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#getAction()
	 */
	public Action getAction()
	{
		return this.action;
	}
	
	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#getParent()
	 */
	public SearchNode getParent()
	{
		return parent;
	}
	
	/**
	 * TODO Autogenerated JavaDoc
	 * @see nl.maastrichtuniversity.dke.libreason.def.treesearch.SearchNode#getDepth()
	 */
	public int getDepth()
	{
		return depth;
	}
}
